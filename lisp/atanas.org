#+Title: Additional Config
#+Author: Atanas Janackovski
#+Date: 2020
This is my config for additional packages and thier associated settings. Some of this is taken from other packages, and I will cite them as appropriate.

* Keybindings
These are keybindings related to built-in features that are not enabled by default.
** Org-mode
A global binding for Org-mode. This has been added to the Org Mode in the =.config.org.=
Org-mode supports [[http://orgmode.org/manual/Hyperlinks.html#Hyperlinks][links]], this command allows you to store links.
globally for later insertion into an Org-mode buffer.
See [[http://orgmode.org/manual/Handling-links.html#Handling-links][Handling-links]] in the Org-mode manual.
#+begin_src emacs-lisp :tangle no
  (define-key global-map "\C-cl" 'org-store-link)
#+end_src
#  LocalWords:  iTerm
* Settings without corresponding packages
** Cleanup-Buffers
This is not currently used. If needed, tangle them.

#+source: cleanup-buffer-on-save
#+begin_src emacs-lisp :tangle no
  ;; Credit: Alex Ott
  (defun cleanup-buffer-hook ()
    "A hook for cleanup-buffer. cleanup-buffer-modes should be a list
    of modes you want the cleanup-buffer function applied to routinely. "
    (when (member major-mode cleanup-buffer-modes)
      (cleanup-buffer)))
  ;; now files int he modes listed in cleanup-buffer-mode will be
  ;; automatically cleaned every time they are saved.
  (add-hook 'before-save-hook 'cleanup-buffer-hook)

#+end_src

#+source: cleanup-buffer-when
#+begin_src emacs-lisp :tangle no
  (setq cleanup-buffer-modes
        '(haskell-mode emacs-lisp-mode lisp-mode scheme-mode
                       ess-mode erlang-mode clojure-mode ruby-mode))

#+end_src

* Third-party packages
** Yasnippet
Yasnippet is a snippet expansion system for Emacs. It uses short phrases and the tab key to trigger the insertion of frequently-used snippets of code or text in your document.

*** Load the yasnippet bundle
#+begin_src emacs-lisp :tangle no
  ;; (add-to-list 'load-path
  ;;                  (expand-file-name  "yasnippet"
  ;;                                     (expand-file-name "elpa"
  ;;                                                       dotfiles-dir)))
  (use-package yasnippet)
  ;;  (yas-set-ac-modes)
  ;;  (yas-enable-emacs-lisp-paren-hack)
  :config (yas-global-mode 1)
#+end_src

Load the snippets defined in the package's =./snippets/= directory, and local snippets from the =./local-snippets/= directory.

#+begin_src emacs-lisp :tangle yes
  (yas-load-directory (expand-file-name "~/.emacs.d/snippets"))
#+end_src

#+begin_src emacs-lisp :tangle no
(defun check-expansion ()
    (save-excursion
      (if (looking-at "\\_>") t
        (backward-char 1)
        (if (looking-at "\\.") t
          (backward-char 1)
          (if (looking-at "->") t nil)))))

  (defun do-yas-expand ()
    (let ((yas-fallback-behavior 'return-nil))
      (yas-expand)))

  (defun tab-indent-or-complete ()
    (interactive)
    (if (minibufferp)
        (minibuffer-complete)
      (if (or (not yas-minor-mode)
              (null (do-yas-expand)))
          (if (check-expansion)
              (company-complete-common)
            (indent-for-tab-command)))))

  (global-set-key [tab] 'tab-indent-or-complete)
#+end_src
** ESS, R, ploy-R and poly-markdown
This is taken mostly from the kjhealy.
*** Load ESS
#+src-name: ess-mode
#+begin_src emacs-lisp
  ;; ===========================
  ;; This solution is working
  ;; ===========================
  (use-package ess)
  (require 'ess-r-mode)
  ;; smart-underscore and ess-smart-S-assign-key have been removed in ESS 19.04 so we need to set them up manually
  (define-key ess-r-mode-map "_" #'ess-insert-assign) ; "_"
  (define-key inferior-ess-r-mode-map "_" #'ess-insert-assign)
#+end_src

*** Use Knitr to process Sweave documents
#+source: knitr-swv
#+begin_src emacs-lisp
  (setq ess-swv-processor "'knitr")
#+end_src

*** Use Polymode
Polymode is a package that supports multiple modes inside a single buffer. It is aimed particularly at literate programming approaches and supports, e.g., R and markdown in a single =.Rmd= file. So it is very useful with knitr in R.

#+source: Polymode
#+begin_src emacs-lisp
  (use-package poly-R)
  (use-package poly-markdown)
#+end_src

*** TODO Make shift-enter do a lot in ESS.
 Use shift-enter to split window & launch R (if not running), execute
 highlighted region (if R running & area highlighted), or execute
 current line (and move to next line, skipping comments). Nice. See
 http://www.emacswiki.org/emacs/EmacsSpeaksStatistics,
 FelipeCsaszar. Adapted to split vertically instead of horizontally.
#+src-name: ess-shift-enter
#+begin_src emacs-lisp
  ;; (setq ess-ask-for-ess-directory nil)
  (setq ess-local-process-name "R")
  (setq ansi-color-for-comint-mode 'filter)
  (setq comint-scroll-to-bottom-on-input t)
  (setq comint-scroll-to-bottom-on-output t)
  (setq comint-move-point-for-output t)

  (defun my-ess-start-R ()
    (interactive)
    (unless (mapcar (lambda (s) (string-match "*R" (buffer-name s))) (buffer-list))
  ;; (unless (string-match "*R" (mapcar (function buffer-name) (buffer-list)))
      (progn
    (delete-other-windows)
    (setq w1 (selected-window))
    (setq w1name (buffer-name))
    (setq w2 (split-window w1 nil t))
    (R)
    (set-window-buffer w2 "*R*")
    (set-window-buffer w1 w1name))))

  (defun my-ess-eval ()
    (interactive)
    (my-ess-start-R)
    (if (and transient-mark-mode mark-active)
    (call-interactively 'ess-eval-region)
      (call-interactively 'ess-eval-line-and-step)))

  (add-hook 'ess-mode-hook
        '(lambda()
           (local-set-key [(shift return)] 'my-ess-eval)))
  (add-hook 'inferior-ess-mode-hook
        '(lambda()
           (local-set-key [C-up] 'comint-previous-input)
           (local-set-key [C-down] 'comint-next-input)))
  (add-hook 'Rnw-mode-hook
          '(lambda()
             (local-set-key [(shift return)] 'my-ess-eval)))

#+end_src

*** TODO Add a Keyboard Shortcut for the Pipe Operator
Assignment in ESS is shift-minus; by extension we'll use M-shift-minus for inserting the `%>%` operator.
Review indentation rules for r-language as size of tabs seems excessive.

#+src-name: ess-pipe-shortcut
#+begin_src emacs-lisp
  (defun my_pipe_operator ()
    "R/ESS %>% operator"
    (interactive)
    (insert " %>% "))

  (define-key ess-mode-map (kbd "M-_") 'my_pipe_operator)
  (define-key inferior-ess-mode-map (kbd "M-_") 'my_pipe_operator)
#+end_src

*** Add a Keyboard Shortcut for Rmd chunks

#+src-name: rmd-chunk-insert
#+BEGIN_SRC emacs-lisp
  ;; Insert new chunk for Rmarkdown
  (defun kjh-insert-r-chunk (header)
    "Insert an r-chunk in markdown mode."
    (interactive "sLabel: ")
    (insert (concat "```{r " header "}\n\n```"))
    (forward-line -1))

  (global-set-key (kbd "\C-c i") 'kjh-insert-r-chunk)
#+END_SRC

*** lintr and flycheck
[[https://github.com/jimhester/lintr][lintr]] checks your R code for style and syntax errors. It's an R library that integrates with [[http://www.flycheck.org][flycheck]]. You must install lintr from R. Flycheck can also check code in many other languages. You will need to install linters for them separately as well. See the flycheck documentation for details.

#+source: lintr
#+begin_src emacs-lisp
  (add-hook 'after-init-hook #'global-flycheck-mode)
  (add-hook 'ess-mode-hook
            (lambda () (flycheck-mode t)))
#+end_src

*** Unused
Code blocks, mostly from kjhealy's config that are not used.
**** Coding Hooks
#+source: ide-ess
#+begin_src emacs-lisp :tangle no
  (add-hook 'ess-mode-hook 'run-starter-kit-coding-hook) ; not sure I need this
  (add-hook 'ess-R-post-run-hook 'smartparens-mode)
#+end_src
**** Define Rnw-mode and make LaTeX aware of it.
If you use Rnw documents, tangle this section. (Rnw files have been mostly superseded by Rmd files.)
#+srcname: misc-r
#+begin_src emacs-lisp :tangle no
  (add-to-list 'auto-mode-alist '("\\.Rnw\\'" . Rnw-mode))
  (add-to-list 'auto-mode-alist '("\\.Snw\\'" . Rnw-mode))

  ;; Make TeX and RefTex aware of Snw and Rnw files
  (setq reftex-file-extensions
        '(("Snw" "Rnw" "nw" "tex" ".tex" ".ltx") ("bib" ".bib")))
  (setq TeX-file-extensions
        '("Snw" "Rnw" "nw" "tex" "sty" "cls" "ltx" "texi" "texinfo"))

  ;; Lets you do 'C-c C-c Sweave' from your Rnw file
  (add-hook 'Rnw-mode-hook
            (lambda ()
              (add-to-list 'TeX-command-list
                           '("Sweave" "R CMD Sweave %s"
                             TeX-run-command nil (latex-mode) :help "Run Sweave") t)
              (add-to-list 'TeX-command-list
                           '("LatexSweave" "%l %(mode) %s"
                             TeX-run-TeX nil (latex-mode) :help "Run Latex after Sweave") t)
              (setq TeX-command-default "Sweave")))
#+end_src
**** TODO Load ESS and configure R-IDE (attempt)
This is a tidy attempt, hacked together form the spacemacs config, however not working. This is much nicer and I will leave here if I get back to it. However, the other solutions above are working.

#+source: ess-r-ides
#+begin_src emacs-lisp :tangle no
  ;; ===========================
  ;; Tidyverse IDE
  ;; ===========================
  ;; This seems to work, however not sure if these will be operational in non-R ess modes
  (use-package ess-site
    :load-path "/elpa/ess/ess-site.el"
    :init
    (ess-mode)
    (defvar ess-enable-smart-equals nil
      "If non-nil smart-equal support is enabled")
    (defun tide_insert_assign ()
      "Insert an assignment <-"
      (interactive)
      (insert " <- "))
    (defun my_pipe_operator ()
      "R/ESS %>% operator"
      (interactive)
      (insert " %>% "))
    :bind
    (:map ess-mode-map
          ("_" . tide_insert_assign)
          ("M-_" . my_pipe_operator))
    (:map inferior-ess-mode-map
          ("_" . tide_insert_assign)
          ("M-_" . my_pipe_operator)))
#+end_src

** Markdown, Pandoc and all things writing
These are where settings for pandoc and markdown related features.

**** Markdown and Marked2.app
Markdown mode support, including preview in =.Marked2.app.=.

#+srcname: markdown-mode
#+begin_src emacs-lisp
  (use-package markdown-mode
    :init
    (autoload 'markdown-mode "markdown-mode"
    "Major mode for editing Markdown files" t)
    (setq auto-mode-alist (cons '("\\.Markdown" . markdown-mode) auto-mode-alist))
    (setq auto-mode-alist (cons '("\\.MarkDown" . markdown-mode) auto-mode-alist))
    (setq auto-mode-alist (cons '("\\.markdown" . markdown-mode) auto-mode-alist))
    (setq auto-mode-alist (cons '("\\.md" . markdown-mode) auto-mode-alist))
    (setq auto-mode-alist (cons '("README\\.md" . gfm-mode) auto-mode-alist))
    :hook ((markdown-mode . visual-line-mode)
           (markdown-mod . latex-unicode-simplified))
    ;; (add-hook 'markdown-mode-hook 'visual-line-mode)
    ;; (add-hook 'markdown-mode-hook 'latex-unicode-simplified)
    )

  ;; (global-visual-line-mode t)
  ;; This function will open Marked.app and monitor the current markdown document
  ;; for anything changes.  In other words, it will live reload and convert the
  ;; markdown documment
  (defun markdown-preview-file ()
    "run Marked on the current file and revert the buffer"
   (interactive)
   (shell-command
   (format "open -a /Applications/Marked\\ 2.app %s" (shell-quote-argument (buffer-file-name)))))

  (global-set-key "\C-co" 'markdown-preview-file)

  (use-package yaml-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.ya?ml$" . yaml-mode))
    (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
    (add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode)))
#+end_src

**** TODO Pandoc
Need to configure specific file types outlined below i.e., tempaltes, etc.
#+source: pandoc
#+begin_src emacs-lisp :tangle yes
  (use-package pandoc-mode
    :hook ((markdown-mode . pandoc-mode)
           (TeX-mode . pandoc-mode)
           (org-mode . pandoc-mode)
           (pandoc-mode . pandoc-load-default-settings)))
#+end_src

**** Spelling
#+source: spelling
#+begin_src emacs-lisp :tangle yes
  ;; can't remember where I found this one
  (defun my-flyspell-mode-hook ()
    ;; Do things when flyspell enters or leaves flyspell mode
    ;; Added manually
    ;;
    ;; Magic Mouse Fixes
    (if flyspell-mode (progn
                        (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
                        (define-key flyspell-mouse-map [mouse-3] #'undefined))
      nil)
    ;; End my-flyspell-mode-hook
    )
  ;; solution from:
  ;; https://emacs.stackexchange.com/questions/9640/could-not-load-package-flyspell-with-use-package
  (use-package flyspell
  :init
  (progn
    (flyspell-mode 1))
  :config
  (progn
    (setq ispell-program-name "aspell")
    (setq ispell-list-command "--list") ;; run flyspell with aspell, not ispell
    )
  :hook ((flyspell-mode . my-flyspell-mode-hook)
         (text-mode . flyspell-mode)
         (prog-mode . flyspell-prog-mode)))

#+end_src

*** CSV mode
View and edit CSV files. See [[http://centaur.maths.qmul.ac.uk/Emacs/][the CSV mode homepage]] for more details.
This is not enabled by default. If needed, tangle.
From the readme:

In CSV mode, the following commands are available:

- C-c C-s (`csv-sort-fields') and C-c C-n (`csv-sort-numeric-fields')
  respectively sort lexicographically and numerically on a
  specified field or column.
- C-c C-r (`csv-reverse-region') reverses the order.  (These
  commands are based closely on, and use, code in `sort.el'.)
- C-c C-k (`csv-kill-fields') and C-c C-y (`csv-yank-fields') kill
  and yank fields or columns, although they do not use the normal
  kill ring.  C-c C-k can kill more than one field at once, but
  multiple killed fields can be yanked only as a fixed group
  equivalent to a single field.
- C-c C-a (`csv-align-fields') aligns fields into columns
- C-c C-u (`csv-unalign-fields') undoes such alignment; separators
  can be hidden within aligned records.
- C-c C-t (`csv-transpose') interchanges rows and columns.  For
  details, see the documentation for the individual commands.

#+srcname csv-mode
#+begin_src elisp :tangle no
  (add-to-list 'auto-mode-alist '("\\.[Cc][Ss][Vv]\\'" . csv-mode))
  (autoload 'csv-mode "csv-mode"
  "Major mode for editing comma-separated value files." t)
#+end_src

*** Multiple Cursors and Undos-Tree
Use multiple cursors for search, replace, and text-cleaning tasks. For a demonstration, see http://emacsrocks.com/e13.html. Tangle if need to use this.

#+source: multiple-cursors
#+begin_src emacs-lisp :tangle yes
  (use-package multiple-cursors)

  ;; When you have an active region that spans multiple lines, the following will add a cursor to each line:
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)

  (global-set-key (kbd "C-S-c C-e") 'mc/edit-ends-of-lines)
  (global-set-key (kbd "C-S-c C-a") 'mc/edit-beginnings-of-lines)

  ;; When you want to add multiple cursors not based on continuous lines, but based on keywords in the buffer, use:
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)

  ;; Rectangular region mode
  (global-set-key (kbd "H-SPC") 'set-rectangular-region-anchor)

  ;; Mark more like this
  (global-set-key (kbd "H-a") 'mc/mark-all-like-this)
  (global-set-key (kbd "H-p") 'mc/mark-previous-like-this)
  (global-set-key (kbd "H-n") 'mc/mark-next-like-this)
  (global-set-key (kbd "H-S-n") 'mc/mark-more-like-this-extended)
  (global-set-key (kbd "H-S-a") 'mc/mark-all-in-region)
#+end_src
#+source: undo-tree
#+begin_src emacs-lisp :tangle no
  ;; not sure that this is needed, as undo tree already and potentially configured.
  ;; review and delete this block if so.
  (use-package undo-tree
    :init (global-undo-tree-mode))
  ;; not sure if this was causing problems, so ~use the statements below instead
  ;;   :config
  ;;   (define-key undo-tree-map (kbd "C-/") nil)
  ;;   (define-key undo-tree-map (kbd "C-_") nil)
  ;;   (define-key undo-tree-map (kbd "C-?") nil)
  ;;   (define-key undo-tree-map (kbd "M-_") nil)
  ;;   (define-key undo-tree-map (kbd "C-z") 'undo-tree-undo)
  ;;   (define-key undo-tree-map (kbd "C-S-z") 'undo-tree-redo))
  (eval-after-load 'undo-tree
    '(progn
       (define-key undo-tree-map (kbd "C-/") nil)
       (define-key undo-tree-map (kbd "C-_") nil)
       (define-key undo-tree-map (kbd "C-?") nil)
       (define-key undo-tree-map (kbd "M-_") nil)
       (define-key undo-tree-map (kbd "C-z") 'undo-tree-undo)
       (define-key undo-tree-map (kbd "C-S-z") 'undo-tree-redo)))
#+end_src

First mark the word, then add more cursors. To get out of multiple-cursors-mode, press <return> or C-g. The latter will first disable multiple regions before disabling multiple cursors. If you want to insert a newline in multiple-cursors-mode, use C-j

*** Delimiters and other stuff
#+source: rainbow-delmitiers
#+begin_src emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :init
    (progn
      (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)))
#+end_src

#+source: aggressive-indent
#+begin_src emacs-lisp :tangle yes
  ;; disable defualt indents
  (electric-indent-mode -1)
  ;; use aggressive indent instead
  (use-package aggressive-indent
    :ensure t
    :init
    (progn
    (global-aggressive-indent-mode 1)))
#+end_src

#+source: paren-face
#+begin_src emacs-lisp :tangle yes
  ;; this package reduces how paren-faces look
  (use-package paren-face
    :init
    (global-paren-face-mode)
    :config
    (add-hook 'prog-mode-hook (lambda () (setq paren-face-regexp "#?[](){}[]"))))
    ;; (add-hook 'clojure-mode-hook (lambda () (setq paren-face-regexp "#?[](){}[]"))))
#+end_src

** Highlight TO-DOs
Highlight various =.ANCHORS.= in comments.

#+source: hl-todo
#+begin_src emacs-lisp :tangle yes
  ;; NOTE that the highlighting works even in comments.
  ;; The below words were configured to make migration my work from vscode to emacs easier
  ;; as they were already words used for project management
  (use-package hl-todo
    :config
    ;; Adding a new keyword: ANCHOR and REVIEW.
    (add-to-list 'hl-todo-keyword-faces '("ANCHOR" . "#dc8cc3"))
    (add-to-list 'hl-todo-keyword-faces '("REVIEW" . "#dca3a3"))
    :init
    (add-hook 'text-mode-hook (lambda () (hl-todo-mode t))))
#+end_src

** TODO Project Management
#+source: projectile
#+begin_src emacs-lisp :tangle yes
  (use-package ag)
  ;; (use-package delight) ; this was used without the doom-modeline
  (use-package projectile
    ;; Remove the mode name for projectile-mode, but show the project name.
    :requires ag
    ;; :delight '(:eval (concat " (╹◡╹) " (projectile-project-name) " (｡◕‿◕｡)")) ; commneted as doom-modeline has taken over
    :init (projectile-global-mode)
    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+end_src

Additionally, I was finding it quite annoying that the temp files would be stored in the relevant project folder, and ended up cluttering things up. So, I made a single backup folder, that needs to be cleared from time-to-time.
#+source: set-backups
#+begin_src emacs-lisp :tangle no
  ;; from here: https://www.emacswiki.org/emacs/AutoSave
  ;; REVIEW consider deleting these if not required
  (setq backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups"))))
#+end_src

#+source: auto-save
#+begin_src emacs-lisp :tangle no
(defun full-auto-save ()
  (interactive)
  (save-excursion
    (dolist (buf (buffer-list))
      (set-buffer buf)
      (if (and (buffer-file-name) (buffer-modified-p))
          (basic-save-buffer)))))
(add-hook 'auto-save-hook 'full-auto-save)
#+end_src

#+source: restart-emacs
#+begin_src emacs-lisp :tangle yes
  ;; get restart-emacs for easy restarting when updating config
  (use-package restart-emacs)
#+end_src

** Keep packages up to date
#+source: updater
#+begin_src emacs-lisp :tangle yes
  (use-package auto-package-update
  :config
  (setq auto-package-update-prompt-before-update t)
  (setq auto-package-update-delete-old-versions t)
  (setq auto-package-update-hide-results t)
  (auto-package-update-maybe))
#+end_src

* Custom scripts
Below are my custom scripts. Please note, any associated keybdings are contained under each relevant section.
** Applescript support
#+srcname: applescript
#+begin_src emacs-lisp
  ;; get applecript support for codeblocks within org
  (use-package ob-applescript)

  ;; general applescript-mode
  (use-package applescript-mode
  :load-path "src/applescript-mode")
#+end_src

** Zotero Cite as You Write
This used `applescript` to access Zotero's citation picker via Better Bibtex.
#+srcname: zotero-cayw
#+begin_src emacs-lisp
  ;; This script needs a citation as it was not written by me.
  (defun zotero-cayw ()
    "Zotero citation picker"
    (interactive)
    (do-applescript
     "tell application \"System Events\"
           try
                 set appName to (the name of every process whose frontmost is true) as string
           on error errMsg
             display alert \"Problem\" message \"Could not get the name of the frontmost application.\"
             error number -128
           end try
     end tell
     set zotRunning to do shell script \"/usr/bin/curl 'http://localhost:23119/better-bibtex/cayw?probe=probe' 2>/dev/null\; exit 0\"
     if zotRunning is \"\" then
         display alert \"Zotero not running\" message \"This script will not work unless Zotero is running. Please launch Zotero and try again\"
         tell application appName
                 activate
           end tell
           error number -128
     else if zotRunning is \"No endpoint found\" then
         display alert \"Better BibTeX not installed\" message \"This script will not work unless Better BibTeX is installed. Please make sure that Better BibTeX is installed in the running instance of Zotero\"
         tell application appName
                 activate
           end tell
           error number -128
     else if zotRunning is \"ready\" then
         set theReference to do shell script \"/usr/bin/curl 'http://localhost:23119/better-bibtex/cayw?format=pandoc' 2>/dev/null\; exit 0\"
         try
                 repeat until application appName is frontmost
                       tell application appName to activate
                 end repeat
           on error errMsg
                 display alert errMsg
           end try
           tell application \"System Events\"
                 try
                       keystroke theReference
                 on error errMsg
                       display alert errMsg
                 end try
           end tell
           end if"))
  ;; set the binding
  (global-set-key (kbd "s-y") 'zotero-cayw)
#+end_src
** iTerm2 integration

#+source: iterm2
#+begin_src emacs-lisp
  ;; from https://sam217pa.github.io/2016/09/01/emacs-iterm-integration/
  ;; return the directory of the file currently opened. If it is a *scratch* buffer or something like that, it simply returns the home directory
  (defun get-file-dir-or-home ()
    "If inside a file buffer, return the directory, else return home"
    (interactive)
    (let ((filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          "~/"
        (file-name-directory filename))))

  ;; cd to the directory of the file I am editing in emacs. If I am in a *scratch* buffer or something like that, it cd to the $HOME directory. It then focus the iTerm2 app.
  (defun iterm-goto-filedir-or-home ()
    "Go to present working dir and focus iterm"
    (interactive)
    (do-applescript
     (concat
      " tell application \"iTerm2\"\n"
      "   tell the current session of current window\n"
      (format "     write text \"cd %s\" \n" (get-file-dir-or-home))
      "   end tell\n"
      " end tell\n"
      " do shell script \"open -a iTerm\"\n"
      ))
    )

  ;; focus the iTerm2 app, without modifying the working directory
  (defun iterm-focus ()
    (interactive)
    (do-applescript
     " do shell script \"open -a iTerm\"\n"
     ))

  (use-package general)

  (general-define-key
   :prefix "C-x"
    "t" '(iterm-focus :which-key "focus iterm")
    "/" '(iterm-goto-filedir-or-home :which-key "focus iterm - goto dir")
    )
#+end_src
